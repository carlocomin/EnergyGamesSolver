/* 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <iostream> 
#include <string>
#include <fstream>
#include <sstream>
#include <random>
#include <chrono>
#include <map>
#include <set>
#include <list>
#include <vector>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h> /* time */
#include "../conf.h"
#include "mpg.h"

using namespace std;

/*****************************************************************************************
*  This program translates a Parity Game generated by "pgsolver" into a Mean Payoff Game 
*****************************************************************************************/

char* INPUT_FILE;
const char* OUTPUT_FILE="data/pg_mpg.dat";
const bool VERBOSE_MODE = true; // initialization needed for mpg.h
unsigned long MAX_WEIGHT=0;
unsigned long MAX_PRIORITY=0;
// maps pg id to mpg id
map<unsigned long, unsigned long> id_map;

ofstream o_stream;

struct t_node{
	unsigned long id;
	long priority;
	bool owner; // true for 1, MAX, white
	vector<unsigned long> suc;
};

struct t_pg{
	unsigned long n;
	unsigned long n_0;
	vector<t_node> nodes;
};

bool invalid_argc(int a);
void load(const char* f, t_pg &pg);
void compute_id_map(t_pg &pg);
void translate_pg2mpg(t_pg &pg, MeanPayoffGame &mpg);
void post_process(MeanPayoffGame &mpg);

int main(int argc, char** argv){
	if(invalid_argc(argc)) return -1;	
	/* initialize random seed: */
	srand(time(NULL));
	INPUT_FILE = argv[1];
	MAX_WEIGHT = atoi(argv[2]);
	o_stream.open(OUTPUT_FILE);
	t_pg pg;
	load(INPUT_FILE, pg);
	compute_id_map(pg);
	unsigned long n_0 = pg.n_0;
	unsigned long n_1 = id_map.size()-n_0;
	MeanPayoffGame mpg(n_0, n_1);
	translate_pg2mpg(pg, mpg);
	mpg.print(); // write to ouput file 
	o_stream.close();
	cout << "Translation completed. See output file " << OUTPUT_FILE << endl;
	return 0;
}

/* Translates the parity game @pg into an MPG @mpg */
void translate_pg2mpg(t_pg &pg, MeanPayoffGame &mpg){
//	unsigned seed = chrono::system_clock::now().time_since_epoch().count();
//	default_random_engine generator (seed);
//	normal_distribution<double> distribution (0.0, MAX_WEIGHT/4);
	vector<t_node>::iterator it = pg.nodes.begin();	
	for(it; it != pg.nodes.end(); it++){
		t_node node = *it;
		vector<unsigned long>::iterator it2 = node.suc.begin();
		for(it2; it2 != node.suc.end(); it2++){
			unsigned long head_idx = *it2;
			if(id_map[head_idx] != id_map[node.id]){ // assume no self loops 
				t_w_arc arc;
				arc.head_idx = id_map[head_idx]; 
				//compute the corresponding weight for MPG
//				double root_exp = 1.0/MAX_PRIORITY;
//				double base = -pow(MAX_WEIGHT, root_exp);
//				long weight = pow(base, node.priority); 	
			/*	int threshold = rand()%100;
				long weight;
				if(threshold <= 25){
					weight = -1;	
				}else if(threshold > 25 && threshold <= 40){
					weight = 0;
				}else{
					weight = distribution(generator);
				}	*/
				arc.weight = pow(-1,rand()%2)*(rand()%(MAX_WEIGHT+1)); 
				/*unsigned int SHIFT_FACTOR=90; 
				arc.weight += MAX_WEIGHT*(SHIFT_FACTOR/100.0); */
				mpg.push_arc(id_map[node.id], arc); 
			}
		}
	}
}

/* Maps @pg vertices ids into MPG vertices ids,
   this is part of the translation procedure */
void compute_id_map(t_pg &pg){
	unsigned long c_MIN=0, c_MAX=0, mpg_id=0, tot_nodes;
	vector<t_node>::iterator it = pg.nodes.begin();
	id_map.clear();
	for(it; it != pg.nodes.end(); it++){
		t_node node = *it;
		tot_nodes++;
		if(id_map.count(node.id)==0){
			if(node.owner){ // owner is MAX
				mpg_id = pg.n_0 + c_MAX++;
				assert(mpg_id <= pg.n);
				pair<unsigned long, unsigned long> entry(node.id, mpg_id);
				id_map.insert(entry);
			}else{ // owner is MIN
				mpg_id = c_MIN++;
				assert(mpg_id <= pg.n);
				pair<unsigned long, unsigned long> entry(node.id, mpg_id);
				id_map.insert(entry);
			}
		}else throw "something goes wrong";	
	}
//	cout << tot_nodes << " " << pg.n+1 << endl;
	assert(tot_nodes==pg.n+1);
}

/* Splits string @s into vector @elems with char delimiter @delim */
vector<unsigned long> &split(const string &s, char delim, vector<unsigned long> &elems) {
    stringstream ss(s);
    string item;
    while (getline(ss, item, delim)) {
	unsigned long i_item = atoi(item.c_str());
        elems.push_back(i_item);
    }
    return elems;
}

/* Splits string @s with char delimiter @delim*/
vector<unsigned long> split(const string &s, char delim) {
    vector<unsigned long> elems;
    split(s, delim, elems);
    return elems;
}

/* loads a pg from filename */
void load(const char* filename, t_pg &pg){
	/*
	* init_steps:
	* 0: name and size
	* 1: node data
	*/
	int init_step = 0;
	/**/
	ifstream input(filename);
	string line;
	if(input.is_open()){
		unsigned long long num_line = 0;
		unsigned long n=0, n_0=0, idx=0, n_id, n_owner;
		long n_priority;
		string name, l_suc;
		vector<unsigned long> v_suc;
		while(getline(input, line)){
			num_line++;
			if(line.compare(0,1,"#")==0) // skip comments
				continue;
			istringstream iss(line);
			switch(init_step){
				case 0:
					iss >> name >> n;
					pg.n = n;
					init_step++;
				break;
				case 1:
					assert(idx <= n);
					iss >> n_id >> n_priority >> n_owner >> l_suc;
					v_suc = split(l_suc, ',');
					t_node n_node;
					n_node.id = n_id;
					n_node.priority = n_priority;
					if(n_priority > MAX_PRIORITY) MAX_PRIORITY = n_priority;
					n_node.owner = n_owner == 1 ? true : false;
					n_0 += ((n_owner+1)%2);
					n_node.suc = v_suc;
					pg.nodes.push_back(n_node);
					idx++;
				break;
			}
		}
		pg.n_0 = n_0;
		assert(idx==n+1);
		input.close();
	}else throw "cannot open input file";
}

/* checks argc validity */
bool invalid_argc(int argc){
	if(argc != 3){
		cout << "Illegal input arguments!" << endl 
		<< "pg2mpg usage is: pg2mpg <input pg file> <max_weight>" << endl;
		return true;
	}
	return false;
}
